'use server';

import { writeFile, mkdir, readFile } from 'fs/promises';
import { join } from 'path';
import type { BrandTheme } from '@/lib/brand-theme';
import { generateGlobalsCss } from '@/lib/brand-theme';

/**
 * Generate markdown content from BrandTheme
 */
function generateBrandMarkdown(theme: BrandTheme): string {
  const colorTable = (colors: object, title: string) => {
    const rows = Object.entries(colors)
      .map(([key, value]) => {
        const cssVar = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
        return `| \`${key}\` | \`${value}\` | \`${cssVar}\` |`;
      })
      .join('\n');
    return `### ${title}\n\n| Token | HEX | CSS Variable |\n| ----- | --- | ------------ |\n${rows}`;
  };

  const spacingRows = Object.entries(theme.spacing)
    .map(([key, value]) => `| \`${key}\` | \`${value}\` |`)
    .join('\n');

  const radiusRows = Object.entries(theme.radius)
    .map(([key, value]) => `| \`${key}\` | \`${value}\` |`)
    .join('\n');

  return `# Brand Design System

> Auto-generated by Theme Editor on ${new Date().toLocaleDateString()}

Design tokens and guidelines for consistent UI across all pages.

---

## Theme: ${theme.name}

---

## Color Palette

${colorTable(theme.colors.light, 'Light Mode Colors')}

${colorTable(theme.colors.dark, 'Dark Mode Colors')}

---

## Typography

### Font Families

| Token | Value |
| ----- | ----- |
| \`sans\` | \`${theme.fonts.sans}\` |
| \`mono\` | \`${theme.fonts.mono}\` |
| \`heading\` | \`${theme.fonts.heading}\` |

### Text Sizes

| Element | Size |
| ------- | ---- |
| \`h1\` | \`${theme.typographySizes.h1}\` |
| \`h2\` | \`${theme.typographySizes.h2}\` |
| \`h3\` | \`${theme.typographySizes.h3}\` |
| \`h4\` | \`${theme.typographySizes.h4}\` |
| \`p\` | \`${theme.typographySizes.p}\` |
| \`blockquote\` | \`${theme.typographySizes.blockquote}\` |
| \`label\` | \`${theme.typographySizes.label}\` |
| \`code\` | \`${theme.typographySizes.code}\` |
| \`table\` | \`${theme.typographySizes.table}\` |
| \`list\` | \`${theme.typographySizes.list}\` |

### Typography Styles

| Property | Value |
| -------- | ----- |
| \`lineHeight\` | \`${theme.typographyStyles.lineHeight}\` |
| \`lineHeightH1\` | \`${theme.typographyStyles.lineHeightH1}\` |
| \`lineHeightH2\` | \`${theme.typographyStyles.lineHeightH2}\` |
| \`lineHeightH3\` | \`${theme.typographyStyles.lineHeightH3}\` |
| \`letterSpacing\` | \`${theme.typographyStyles.letterSpacing}em\` |

---

## Spacing Scale

| Token | Value |
| ----- | ----- |
${spacingRows}

---

## Border Radius

| Token | Value |
| ----- | ----- |
${radiusRows}

---

## Buttons

| Property | Value |
| -------- | ----- |
| \`borderRadius\` | \`${theme.buttons.borderRadius}\` |
| \`fontWeight\` | \`${theme.buttons.fontWeight}\` |

---

## Raw Theme JSON

\`\`\`json
${JSON.stringify(theme, null, 2)}
\`\`\`
`;
}

export interface SaveBrandResult {
  success: boolean;
  message: string;
  markdown?: string;
}

/**
 * Save the brand theme to docs/brand.md
 */
export async function saveBrandDoc(theme: BrandTheme): Promise<SaveBrandResult> {
  try {
    const markdown = generateBrandMarkdown(theme);
    const docsPath = join(process.cwd(), 'docs');
    const filePath = join(docsPath, 'brand.md');

    // Ensure docs directory exists
    await mkdir(docsPath, { recursive: true });

    // Write the markdown file
    await writeFile(filePath, markdown, 'utf-8');

    return {
      success: true,
      message: 'Successfully saved brand.md',
      markdown,
    };
  } catch (error) {
    console.error('Failed to save brand.md:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Failed to save brand.md',
    };
  }
}

/**
 * Export theme as JSON string
 */
export async function exportThemeJson(theme: BrandTheme): Promise<string> {
  return JSON.stringify(theme, null, 2);
}

export interface ApplyThemeResult {
  success: boolean;
  message: string;
}

/**
 * Apply the brand theme to the entire project by saving it as a JSON file.
 * The /theme.css route reads this file and generates CSS variables.
 * @deprecated Use applyThemeToGlobals instead
 */
export async function applyThemeToProject(theme: BrandTheme): Promise<ApplyThemeResult> {
  try {
    const docsPath = join(process.cwd(), 'docs');
    const filePath = join(docsPath, 'brand-theme.json');

    // Ensure docs directory exists
    await mkdir(docsPath, { recursive: true });

    // Write the theme as JSON
    const themeJson = JSON.stringify(theme, null, 2);
    await writeFile(filePath, themeJson, 'utf-8');

    return {
      success: true,
      message: 'Theme applied to project successfully',
    };
  } catch (error) {
    console.error('Failed to apply theme to project:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Failed to apply theme to project',
    };
  }
}

/**
 * Apply the brand theme by directly overwriting globals.css
 * Replaces the :root and .dark blocks with the new theme values
 * Also updates docs/brand.md with the theme documentation
 */
export async function applyThemeToGlobals(theme: BrandTheme): Promise<ApplyThemeResult> {
  try {
    const globalsPath = join(process.cwd(), 'src', 'app', 'globals.css');
    const docsPath = join(process.cwd(), 'docs');
    const brandMdPath = join(docsPath, 'brand.md');

    // Perform all operations in parallel for better performance
    const [currentCss] = await Promise.all([
      readFile(globalsPath, 'utf-8'),
      mkdir(docsPath, { recursive: true }), // Ensure docs directory exists early
    ]);

    // Generate the new :root and .dark blocks
    const { root, dark } = generateGlobalsCss(theme);

    // Replace :root block - matches from ":root {" to the closing "}"
    const rootRegex = /:root\s*\{[\s\S]*?\n\}/;
    let updatedCss = currentCss.replace(rootRegex, root);

    // Replace .dark block - matches from ".dark {" to the closing "}"
    const darkRegex = /\.dark\s*\{[\s\S]*?\n\}/;
    updatedCss = updatedCss.replace(darkRegex, dark);

    // Generate markdown
    const markdown = generateBrandMarkdown(theme);

    // Write both files in parallel for faster execution
    await Promise.all([
      writeFile(globalsPath, updatedCss, 'utf-8'),
      writeFile(brandMdPath, markdown, 'utf-8'),
    ]);

    return {
      success: true,
      message: 'Theme applied to globals.css and brand.md successfully',
    };
  } catch (error) {
    console.error('Failed to apply theme to globals.css:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Failed to apply theme to globals.css',
    };
  }
}
